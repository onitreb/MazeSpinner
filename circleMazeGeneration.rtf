{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 There happens to be a class of grid that works really well for circles, though. It\'92s called a polar grid, and the mazes we build with it are called theta, or circle mazes. In this chapter, you\'92ll see how to use these grids to turn out circle mazes that look much like this one: report erratum \'95 discuss To get there, we\'92ll begin by talking about polar grids and how they differ from what we\'92ve done so far. Then we\'92ll introduce a new Grid subclass where we\'92ll rewrite our to_png method to support this new way of thinking about grids, and finally we\'92ll look at how to make the cells of the grid as evenly sized as possible. Understanding Polar Grids Whereas the orthogonal grids we\'92re used to are composed of rows and columns of cells, polar grids are composed of rings of concentric circles, each divided into cells like the spokes of a wagon wheel. There are going to be lots of ways we could represent one of these in code, but it turns out that we can reuse our existing grid class with just a few changes. We\'92ll work through them in stages, starting with what it will take to draw a polar grid. If we can draw one, we\'92ve got the problem more than half licked! At the beginning, we start with a few given values. These include the height of each ring (we\'92ll call it ring_height), and how many cells exist in the ring (or cell_count). With those, we can then define the geometry of a given cell, like this: theta = 2 * Math::PI / cell_count inner_radius = cell.row * ring_height outer_radius = (cell.row + 1) * ring_height theta_ccw = cell.col * theta theta_cw = (cell.col + 1) * theta Chapter 7. Going in Circles \'95 98 report erratum \'95 discuss The theta variable describes the angular size of every cell in the ring. If a complete circle describes an angle of 2 * Math::PI radians, then we can simply divide that by the number of cells in the ring to see how many radians are covered by a single cell. The inner_radius and outer_radius variables tell us how far the cell is from the origin, with the inner value describing the distance of the inward wall and the outer value describing the distance of the outward wall. The last two variables are used to describe where the counter-clockwise and clockwise walls of the cell are, in radians. The counter-clockwise wall is described by theta_ccw, which is simply the angle around the circle to that wall. Likewise, theta_cw describes the angle to the clockwise wall. Let\'92s put these on a diagram and see if they make more sense. The following diagram zooms in on our polar grid, looking at one arbitrary cell whose corners are A, B, C, and D. \uc0\u952  A C D B inner outer counterclockwise (ccw) clockwise (cw) Figure 2\'97Describing a Cell in Polar Coordinates We can see that \u952  (theta) is the angular size of the cell, and the inner and outer radii are the distances from the origin to the cell\'92s walls. Further, the AB wall is the counter-clockwise one, and CD is the clockwise one, both being some multiple of \u952  radians around the circle. Right? Whew! The next step, because most image libraries don\'92t understand polar coordinates, is to convert them to Cartesian coordinates\'97the x,y pairs that are typically used to address locations in images. We\'92re going to resort to triangles to help us with the conversion, measuring the x and y distances of the point from the origin of the grid. We\'92ll need to resort to a bit of trigonometry, but report erratum \'95 discuss Understanding Polar Grids \'95 99 don\'92t worry if it\'92s been awhile since you\'92ve stretched those muscles. We\'92ll walk through this together. Here\'92s a diagram, in case you need a refresher of how the sides of a right triangle relate to the hypotenuse. The hypotenuse is labeled r: \u952  x r y x = r\u8901 cos\u952  y = r\u8901 sin\u952  It\'92s always helped me to remember that sine and cosine correspond alphabetically to x and y. Just as cosine comes before sine in the dictionary, so x comes before y, which suggests that we\'92ll use cosine to compute x, and sine to compute y. Multiplying the hypotenuse by the cosine or sine of the angle \u952  will give us, respectively, the x or y distance from the origin. Referring back to Figure 2, Describing a Cell in Polar Coordinates, on page 99, it\'92s not much of a stretch to imagine a triangle superimposed, with A (or B) at the upper right and the grid origin in the lower left. If the inner and outer radii are the hypotenuse, we can use those trig formulas to get us the Cartesian coordinates we need. Thanks to trig, then, we now know everything we need to describe the four corners of the cell, labeled A, B, C, and D in Figure 2, Describing a Cell in Polar Coordinates, on page 99. Assuming center_x and center_y are the coordinates of the origin of our circle, our cell\'92s coordinates become: ax = center_x + inner_radius * Math.cos(theta_ccw) ay = center_y + inner_radius * Math.sin(theta_ccw) bx = center_x + outer_radius * Math.cos(theta_ccw) by = center_y + outer_radius * Math.sin(theta_ccw) cx = center_x + inner_radius * Math.cos(theta_cw) cy = center_y + inner_radius * Math.sin(theta_cw) dx = center_x + outer_radius * Math.cos(theta_cw) dy = center_y + outer_radius * Math.sin(theta_cw) All that\'92s left, then, is to draw it. Chapter 7. Going in Circles \'95 100 report erratum \'95 discuss Drawing Polar Grids The to_png method we\'92ve used to this point isn\'92t going to help us much with polar grids, so let\'92s just subclass Grid and rewrite to_png to be what we need it to be. Create a new file, named polar_grid.rb. We\'92ll start it off with the following Grid subclass and to_png implementation. polar_grid.rb Line 1 require 'grid' - - class PolarGrid < Grid - def to_png(cell_size: 10) 5 img_size = 2 * @rows * cell_size - - background = ChunkyPNG::Color::WHITE - wall = ChunkyPNG::Color::BLACK - 10 img = ChunkyPNG::Image.new(img_size + 1, img_size + 1, background) - center = img_size / 2 - - each_cell do |cell| - theta = 2 * Math::PI / @grid[cell.row].length 15 inner_radius = cell.row * cell_size - outer_radius = (cell.row + 1) * cell_size - theta_ccw = cell.column * theta - theta_cw = (cell.column + 1) * theta - 20 ax = center + (inner_radius * Math.cos(theta_ccw)).to_i - ay = center + (inner_radius * Math.sin(theta_ccw)).to_i - bx = center + (outer_radius * Math.cos(theta_ccw)).to_i - by = center + (outer_radius * Math.sin(theta_ccw)).to_i - cx = center + (inner_radius * Math.cos(theta_cw)).to_i 25 cy = center + (inner_radius * Math.sin(theta_cw)).to_i - dx = center + (outer_radius * Math.cos(theta_cw)).to_i - dy = center + (outer_radius * Math.sin(theta_cw)).to_i - - img.line(ax, ay, cx, cy, wall) unless cell.linked?(cell.north) 30 img.line(cx, cy, dx, dy, wall) unless cell.linked?(cell.east) - end - - img.circle(center, center, @rows * cell_size, wall) - img 35 end end - This new to_png method starts much like the old version, computing the size of our canvas. In this case, though, the canvas width and height will be the report erratum \'95 discuss Drawing Polar Grids \'95 101 diameter of our circle, or twice the radius, which is the number of rows, times the height of each row (line 5). The center of the grid, then, will be the center of our circle, and is computed to be half the diameter (line 11). Now, for each cell in the grid, lines 14\'9618 measure the inner and outer radii, and the associated angles, which are then used on lines 20\'9627 to compute the coordinates of each corner of the cell. (That part should look very familiar, from the previous section.) Note that we convert each coordinate to an integer, because ChunkyPNG doesn\'92t deal well with non-integer arguments. Once we have those coordinates, lines 29 and 30 use them to draw the inward and clockwise walls of the cell. (For now, we\'92ll refer to those directions as north and east, respectively, since they correspond neatly to the underlying orthogonal grid. We\'92ll get fancy soon enough and create a custom Cell subclass.) Last of all, we draw the outer wall of the grid as a whole circle (line 33), and then return our image. Joe asks: Why Are We Drawing Lines Instead of Arcs? Good catch! Ideally, we\'92d draw the inner wall on line 29 with an arc, to follow the curve of the circle, but as of this writing ChunkyPNG does not provide an API for drawing arcs. It turns out that straight lines do (mostly) well enough, but if you\'92re using a different image library with your own code, maybe check to see if it supports arc drawing. Let\'92s check to see that this is working now. Put the following in a file called polar_grid_test.rb. polar_grid_test.rb require 'polar_grid' grid = PolarGrid.new(8, 8) filename = "polar.png" grid.to_png.save(filename) puts "saved to #\{filename\}" We create a new polar grid with eight rows (or rings), and eight columns (the spokes of the wheels), and then simply display the result. Since we\'92re not trying to generate a maze on it, it should simply save the grid itself. Sure enough, we get the following: Chapter 7. Going in Circles \'95 102 report erratum \'95 discuss It\'92s not great (the straight lines give it a decidedly cobweb-ish look), but it\'92s enough to show us that we\'92re on the right track. It\'92s a recognizable polar grid. At this point we could even run one of our maze algorithms, but I wouldn\'92t recommend it\'97not yet, anyway. For example, here is the same grid with the Recursive Backtracker applied to it: It\'92s an intriguing pattern, but not really what we\'92re going for here. The outermost cells are far too wide compared to the innermost cells, contributing to a very uneven look, and although it is technically a maze, it lacks the expected aesthetic of a maze. What we need is a way to keep the cells as evenly sized as possible, even as the concentric circles of the grid grow larger and larger. To solve this, we need to look at a technique for dividing cells when they get too large, called adaptive subdivision. Adaptively Subdividing the Grid In order to use adaptive subdivision to make our cells more uniform in size, we need to know about what size they ought to be. Squares look pretty good in an orthogonal grid, but polar grids can\'92t give us real squares. There are no parallel lines in a polar grid! But although we can\'92t have squares, we can approximate them. We\'92ll just say we want the length of the inner wall to be approximately the same as the height of the cell (the distance between the inner and outer walls). report erratum \'95 discuss Adaptively Subdividing the Grid \'95 103 With that rule in mind, look at the figure, which shows one \'93column\'94 of our polar grid, and take steps to make it a bit more uniform. First, we look at the two innermost cells and see that they both fit the bill. Their inner walls aren\'92t longer than the cells are tall. But the next cell\'85ouch. It\'92s quite a bit wider. To fix that, we divide the cell\'97and all subsequent cells\'97into two, like this: That third row now looks pretty good, and the fourth row, too (though it\'92s definitely getting a bit wide). The fifth row, however, sounds some alarms. Way too wide. The answer? Subdivide again. At this point, our original column has branched out to become multiple columns. The cells look much more regular now, but this comes at a cost: we\'92ve added some complexity by splitting the cells, so that some now have two neighbors in the outward direction, instead of just one. Fortunately, it\'92s not too difficult to keep under control, as we\'92ll see in the next section when we bring it all together in code. Implementing a Polar Grid To implement this improved polar grid, we\'92re going to introduce a new Cell subclass, and then walk through how these new cells will be laid out and subdivided. We\'92ll finish it all off with one last mostly cosmetic tweak to make our final maze as tidy as possible. The PolarCell Class First, the new Cell subclass. We\'92ve made do so far with using the existing Cell class, but it\'92s getting a bit unwieldy to keep referring to compass directions when they don\'92t map very intuitively to a polar grid. Also, with adaptive subdivision, some cells may now have two neighbors in the outward direction, and our existing Cell class has no support for that. So, put the following in polar_cell.rb. Chapter 7. Going in Circles \'95 104 report erratum \'95 discuss polar_cell.rb Line 1 require 'cell' - - class PolarCell < Cell - attr_accessor :cw, :ccw, :inward 5 attr_reader :outward - - def initialize(row, column) - super @outward = [] end - 10 - - def neighbors - list = [] - list << cw if cw 15 list << ccw if ccw - list << inward if inward - list += outward - list - end end 20 Lines 4 and 5 start things off by defining attributes for the polar directions: clockwise (cw), counter-clockwise (ccw), inward (toward the origin), and outward (toward the rim). Refactoring the Cell Class At this point, you might want to take some time to do a proper refactoring of Cell, so that subclasses don\'92t inherit unnecessary baggage (like north, south, and so forth). Projects that grow organically, like ours, often go through refactoring iterations to \'93tidy up\'94 as the code grows and matures. It\'92s sadly beyond the scope of this book to do so here, but don\'92t let that stop you! Note that line 5 grants outward only a reader, not a writer, because we won\'92t be assigning to it directly. Instead, in the constructor on line 9 we initialize outward to be an empty array, and we\'92ll just append cells to it as needed. There. With our new cell class ready, we can return to PolarGrid and start fleshing that out a bit more. Revisiting PolarGrid Our updated polar grid implementation will override several methods of the base class, including the constructor, prepare_grid, configure, and others. We\'92ll open up polar_grid.rb again and make all of the following changes there. report erratum \'95 discuss Implementing a Polar Grid \'95 105 First, let\'92s add a dependency on our new PolarCell class. require 'grid' \u10148  require 'polar_cell' Next, we\'92ll create a new constructor for PolarGrid. Up to this point, we\'92ve been telling every grid how many rows and columns it has, but adaptive subdivision allows us to compute the number of columns per row. All we really need to tell our grid is the number of rows\'97we can get everything else from that. Put this at the top of the PolarGrid class, before the to_png method. def initialize(rows) super(rows, 1) end The second parameter in the super call is required because the superclass needs to know how many columns the grid has (arguably a design flaw, but we\'92ll live with it). The next method is meaty. We\'92re going to override prepare_grid and change it up so that instead of building a regular grid as it\'92s been doing, we\'92re going to prepare our adaptively subdivided polar grid. Add the following method just after the initialize method. Line 1 def prepare_grid - rows = Array.new(@rows) - - row_height = 1.0 / @rows 5 rows[0] = [ PolarCell.new(0, 0) ] - - (1...@rows).each do |row| - radius = row.to_f / @rows - circumference = 2 * Math::PI * radius 10 - previous_count = rows[row - 1].length - estimated_cell_width = circumference / previous_count - ratio = (estimated_cell_width / row_height).round - 15 cells = previous_count * ratio rows[row] = Array.new(cells) \{ |col| PolarCell.new(row, col) \} end - - - - end rows 20 Even though it\'92s a polar grid, we\'92re still going to use arrays to represent each row. Line 2 sets that up for us. Chapter 7. Going in Circles \'95 106 report erratum \'95 discuss Line 4 then computes the height of each individual row. We don\'92t know, at this point, how large the circle will be when it\'92s rendered, but that\'92s okay. We can just assume that we\'92re working with a unit circle\'97that is, a circle with a radius of 1\'97and the laws of geometry assure us that we can resize it painlessly later. This lets us simplify many of the calculations. Next, line 5 treats the origin of our circle\'97row #0\'97as a special case. Because all the radii meet at the origin, splitting that row into more than one cell means the cells get small, fast. Instead, we\'92ll force that innermost row to be a single cell, with coordinates 0, 0. Now, for each of the remaining rows, we\'92re going to do some computation to figure out how to subdivide things. Line 8 computes the inner radius of the row\'97the distance from the origin to the row\'92s inner wall\'97and then uses that to compute the circumference of that wall (line 9). Remember, we\'92re working with a unit circle, here, so the radius of a given row is just the ratio of the row\'92s index to the number of rows. (Isn\'92t that convenient?) Then, line 12 divides that circumference by the number of cells in the previous row, which tells us how wide each cell would be in this row if we don\'92t subdivide. That\'92s the ideal condition\'97we don\'92t want to subdivide unless we have to! Recall that our ideal cell width is the same as the height of the row. Line 13 uses that ideal to see how many ideally sized cells could fit into our estimated_cell_width. This ratio variable essentially tells us how many cells in this row correspond to each cell in the previous row. If ratio is 1, then the current row will have the same number of cells as the previous row. If it is 2 (or more), then we\'92re subdividing. The ratio will always be either 1 or 2, except for the row at index 1. The ratio there may be larger because the previous row (at index 0) always contains only a single cell. Lastly, we take the ratio and multiply it by the number of cells in the previous row (line 15). This tells us how many cells should be in the current row, so we finish the loop off by instantiating a new array with the corresponding number of PolarCell instances (line 16). Whew! At this point, then, we\'92ve got our grid, but we\'92re not yet setting up the adjacency information for the individual cells. The poor little dears have no idea who their neighbors are. For this, we need to override the configure_cells method. Line 1 def configure_cells - each_cell do |cell| - row, col = cell.row, cell.column - report erratum \'95 discuss Implementing a Polar Grid \'95 107 5 if row > 0 - cell.cw = self[row, col + 1] - cell.ccw = self[row, col - 1] - - ratio = @grid[row].length / @grid[row - 1].length 10 parent = @grid[row - 1][col / ratio] - parent.outward << cell - cell.inward = parent - end - end end 15 Here, we\'92re going to look at each cell in the grid, ignoring only the cell at the origin (line 5) because it\'92s our special case and has no inward or clockwise neighbors. For the other cells, we set up their clockwise (line 6) and counter-clockwise (line 7) neighbors, compute the ratio of cells in this row to the cells in the previous row (line 9), and then use that to decide which cell in the previous row is the \'93parent\'94\'97the cell that may or may not have been subdivided to produce the current cell (line 10). The current cell is then added as one of the outward neighbors of that parent (line 11), and the parent is set to be the inward neighbor of the current cell (line 12). We only need to add one more new method, to help us select a random cell from the grid. This one is easy, a breath of fresh air after the previous two. def random_cell row = rand(@rows) col = rand(@grid[row].length) @grid[row][col] end And finally, we need to make a few changes to to_png to accommodate our new neighbor names (cw, ccw, and so forth) as well as the special case around the cell at the origin. Change (or add to, as necessary) your copy of the to_png to make it match the highlighted lines in the following code. each_cell do |cell| \u10148  next if cell.row == 0 # ... \u10148  img.line(ax, ay, cx, cy, wall) unless cell.linked?(cell.inward) \u10148  img.line(cx, cy, dx, dy, wall) unless cell.linked?(cell.cw) end Easy enough! We\'92re almost done. Chapter 7. Going in Circles \'95 108 report erratum \'95 discuss Testing and Tweaking We\'92re on the final stretch. All that\'92s left is to test what we\'92ve got, then tweak one final thing so the finished product looks as good as we can make it. Our existing polar_grid_test.rb won\'92t work right now, because we\'92re instantiating the PolarGrid with too many arguments. Go ahead and open that file up and change it so that we pass only a single argument to the constructor\'97the number of rows\'97and try it all again. grid = PolarGrid.new(8) This time around, we should get something much less cobweb-ish and much more interesting. Nice! And if we then generate a maze on that grid, we ought to see a thing of beauty. Put the following in circle_maze.rb and give it a try. It uses the Recursive Backtracker algorithm, but Aldous-Broder or Wilson\'92s ought to work equally well if you want to experiment with other algorithms. circle_maze.rb require 'polar_grid' require 'recursive_backtracker' grid = PolarGrid.new(8) RecursiveBacktracker.on(grid) filename = "circle_maze.png" grid.to_png.save(filename) puts "saved to #\{filename\}" The result? Behold! Well\'85but, wait. It\'92s almost a thing of beauty. There\'92s one little blemish keeping it back from blissful, circular perfection. Do you see it? report erratum \'95 discuss Implementing a Polar Grid \'95 109 It\'92s that radial line, marking the boundary between the clockwise and counterclockwise edges of our grid. It may seem like a small thing, but try generating a few of these mazes. Make them bigger, with 25 rows or more. That little radial line will rapidly grow tiresome! To fix it, we simply need to tell the grid that the cells on the clockwise boundary are adjacent to the cells on the counter-clockwise boundary. We could do this by further modifying the configure_cells method, but if we took that route we\'92d wind up having to perform the same check twice\'97once for the clockwise neighbor, and once for the counter-clockwise neighbor. We can avoid the duplication by moving that check into the array accessor method itself, as in the following code. Go ahead and add it to the PolarGrid class, just before the random_cell method. def [](row, column) return nil unless row.between?(0, @rows - 1) \u10148  @grid[row][column % @grid[row].count] end The highlighted line is where the magic happens. Notice that we\'92re no longer checking the bounds on the column parameter. Instead, we\'92re using modulus arithmetic to make sure that the column is always wrapped to fit within those bounds. In this way, the clockwise boundary and the counter-clockwise boundary effectively become adjacent.}